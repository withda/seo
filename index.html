<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>내맘대로 글써주는놈</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');
    
    :root {
      --primary-color: #e53e3e;
      --secondary-color: #d53f8c;
      --accent-color: #fbb6ce;
      --background-gradient: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
      --card-background: rgba(255,255,255,0.95);
      --border-radius: 12px;
      --box-shadow: 0 8px 32px rgba(255,182,193,0.3);
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0; 
    }
    
    body { 
      font-family: 'Poppins', sans-serif; 
      max-width: 900px; 
      margin: 0 auto; 
      padding: 1rem;
      background: var(--background-gradient);
      min-height: 100vh;
      color: #2d3748;
      line-height: 1.6;
    }
    
    h1 { 
      text-align: center; 
      color: var(--primary-color);
      font-weight: 700;
      font-size: 2rem;
      text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
      margin-bottom: 1.5rem;
      line-height: 1.2;
    }
    
    h2 {
      color: var(--secondary-color);
      font-weight: 600;
      margin-bottom: 1rem;
      font-size: 1.2rem;
    }
    
    .section { 
      background: var(--card-background);
      backdrop-filter: blur(10px);
      border: none;
      padding: 1.5rem; 
      margin-bottom: 1rem;
      border-radius: var(--border-radius); 
      box-shadow: var(--box-shadow);
      border: 1px solid rgba(255,255,255,0.2);
    }
    
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    .section input[type="text"], 
    .section input[type="password"] {
      width: 100%; 
      padding: 12px 16px;
      border: 2px solid var(--accent-color);
      border-radius: var(--border-radius);
      font-size: 1rem;
      transition: var(--transition);
      background: rgba(255,255,255,0.9);
      font-family: inherit;
    }
    
    .section input[type="text"]:focus, 
    .section input[type="password"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(229,62,62,0.1);
      transform: translateY(-1px);
    }
    
    .btn {
      padding: 12px 24px; 
      background: linear-gradient(135deg, var(--primary-color) 0%, #f56565 100%);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      font-size: 1rem;
      width: 100%;
      font-family: inherit;
      position: relative;
      overflow: hidden;
    }
    
    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(229,62,62,0.3);
    }
    
    .btn:disabled {
      background: #cbd5e0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .helper { 
      font-size: 0.85rem; 
      color: #718096; 
      line-height: 1.5;
      margin-top: 0.5rem;
    }
    
    .error-message {
      color: #e53e3e;
      font-size: 0.85rem;
      margin-top: 0.5rem;
      padding: 0.5rem;
      background: rgba(229, 62, 62, 0.1);
      border-radius: 4px;
      border-left: 3px solid #e53e3e;
    }
    
    .success-message {
      color: #38a169;
      font-size: 0.85rem;
      margin-top: 0.5rem;
      padding: 0.5rem;
      background: rgba(56, 161, 105, 0.1);
      border-radius: 4px;
      border-left: 3px solid #38a169;
    }
    
    #articles { 
      max-height: 300px; 
      overflow-y: auto; 
      border: 2px solid var(--accent-color); 
      padding: 1rem; 
      font-size: 0.9rem;
      border-radius: var(--border-radius);
      background: rgba(255,255,255,0.8);
    }
    
    .article-item { 
      display: flex; 
      align-items: flex-start; 
      margin-bottom: 0.8rem;
      padding: 8px;
      border-radius: 8px;
      transition: background 0.2s ease;
    }
    
    .article-item:hover {
      background: rgba(255,182,193,0.2);
    }
    
    .article-item input[type="radio"] { 
      margin-right: 0.8rem;
      margin-top: 2px;
      accent-color: var(--primary-color);
      flex-shrink: 0;
    }
    
    .article-item label { 
      flex: 1; 
      cursor: pointer;
      font-weight: 400;
      line-height: 1.4;
      word-break: break-word;
    }
    
    #preview { 
      background: rgba(255,255,255,0.9);
      padding: 1.5rem;
      border-radius: var(--border-radius);
      margin-top: 1rem;
      border: 2px solid var(--accent-color);
      max-height: 500px;
      overflow-y: auto;
      word-break: break-word;
      line-height: 1.8;
    }
    
    #preview img { 
      display: block; 
      width: 100%; 
      height: auto; 
      object-fit: contain; 
      margin: 1rem 0;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    
    #preview h3 {
      color: var(--secondary-color);
      margin-bottom: 1rem;
      font-weight: 600;
      font-size: 1.3rem;
      line-height: 1.3;
    }
    
    .hidden { 
      display: none !important; 
    }
    
    .export-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 0.8rem;
      margin: 1rem 0;
    }
    
    .export-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
      font-size: 0.9rem !important;
      padding: 10px 16px !important;
      margin: 0 !important;
    }
    
    .content-section {
      margin: 2rem 0;
      padding: 1.5rem;
      background: rgba(255,255,255,0.9);
      border-radius: var(--border-radius);
      border: 2px solid var(--accent-color);
    }
    
    .section-title {
      color: var(--secondary-color);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      font-size: 1.1rem;
      font-weight: 600;
    }
    
    /* 모바일 반응형 디자인 */
    @media (max-width: 768px) {
      body {
        padding: 0.5rem;
      }
      
      h1 {
        font-size: 1.8rem;
        margin-bottom: 1rem;
      }
      
      .section {
        padding: 1rem;
      }
      
      .export-grid {
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <h1>Suah AI Auto Posting</h1>

  <div class="section">
    <h2>내맘대로 글써주는놈</h2>
    <div class="input-group">
      <input type="password" id="openai_key" placeholder="OpenAI API Key (sk-...)" />
      <div id="openai_error" class="error-message hidden">올바른 OpenAI API 키 형식이 아닙니다.</div>
    </div>
    <div class="input-group">
      <input type="text" id="pexels_key" placeholder="Pexels API Key" />
      <div id="pexels_error" class="error-message hidden"> API 키를 입력해주세요.</div>
    </div>
    <button id="saveKeysBtn" class="btn">저장</button>
    <div id="keys_success" class="success-message hidden">API 키가 저장되었습니다.</div>
  </div>

  <div class="section">
    <h2>기사 검색하는 곳</h2>
    <div class="input-group">
      <input type="text" id="query" placeholder="검색어 입력" />
      <div class="helper">예: 아이폰, 삼성, 코인, 주식 등</div>
    </div>
    <button id="searchBtn" class="btn">검색</button>
    <div id="articles"></div>
  </div>

  <div class="section hidden" id="actions">
    <h2>생성 & 미리보기</h2>
    <button id="generateBtn" class="btn">생성</button>
    <div id="preview"></div>
    
    <div id="exportOptions" class="hidden">
      <div class="section-title">
        <span>📋</span>내보내기 옵션
      </div>
      <div class="export-grid">
        <button id="copyHtmlBtn" class="btn export-btn">📄 HTML 복사</button>
        <button id="copyMarkdownBtn" class="btn export-btn">📝 Markdown 복사</button>
        <button id="downloadHtmlBtn" class="btn export-btn">💾 HTML 저장</button>
        <button id="downloadMarkdownBtn" class="btn export-btn">💾 MD 저장</button>
        <button id="captureBtn" class="btn export-btn">📸 이미지 저장</button>
      </div>
    </div>
  </div>

<script>
// 설정 및 상수
const CONFIG = {
  MAX_ARTICLES: 30,
  FETCH_TIMEOUT: 15000,
  OPENAI_API_KEY_PATTERN: /^sk-[a-zA-Z0-9]{20,}$/,
  PEXELS_API_KEY_MIN_LENGTH: 10
};

// 유틸리티 클래스
class Utils {
  static sanitizeText(text) {
    const div = document.createElement('div');
    div.textContent = text || '';
    return div.innerHTML;
  }
  
  static validateOpenAIKey(key) {
    return CONFIG.OPENAI_API_KEY_PATTERN.test(key?.trim());
  }
  
  static validatePexelsKey(key) {
    return key?.trim().length >= CONFIG.PEXELS_API_KEY_MIN_LENGTH;
  }
  
  static showMessage(elementId, message, isError = false) {
    const element = document.getElementById(elementId);
    if (element) {
      element.textContent = message;
      element.classList.remove('hidden');
      setTimeout(() => element.classList.add('hidden'), isError ? 5000 : 3000);
    }
  }
}

// API 관리 클래스
class ApiManager {
  static async fetchWithTimeout(url, options = {}, timeout = CONFIG.FETCH_TIMEOUT) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }
  
  static async callOpenAI(prompt, temperature = 0.6) {
    const apiKey = localStorage.getItem('openai_key');
    if (!Utils.validateOpenAIKey(apiKey)) {
      throw new Error('유효하지 않은 OpenAI API 키입니다.');
    }
    
    const response = await this.fetchWithTimeout('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [{
          role: 'system',
          content: '당신은 키워드 스터핑을 절대 하지 않는 전문 SEO 라이터입니다.'
        }, {
          role: 'user',
          content: prompt
        }],
        temperature,
        max_tokens: 4000
      })
    });
    
    if (!response.ok) {
      throw new Error(`OpenAI API 오류: ${response.status}`);
    }
    
    return response.json();
  }
  
  static async searchPexelsImage(query) {
    const apiKey = localStorage.getItem('pexels_key');
    if (!Utils.validatePexelsKey(apiKey)) {
      return null;
    }
    
    try {
      const response = await this.fetchWithTimeout(
        `https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=1`,
        { headers: { Authorization: apiKey } }
      );
      
      if (!response.ok) return null;
      
      const data = await response.json();
      return data.photos?.[0]?.src?.large2x || null;
    } catch (error) {
      console.warn('Pexels search failed:', error);
      return null;
    }
  }
}

// 뉴스 검색 클래스
class NewsSearcher {
  static PROXIES = [
    url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
    url => `https://thingproxy.freeboard.io/fetch/${url}`,
    url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`
  ];
  
  static async fetchWithProxies(url) {
    for (const proxyFn of this.PROXIES) {
      try {
        const response = await ApiManager.fetchWithTimeout(proxyFn(url));
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.text();
      } catch (error) {
        console.warn('Proxy failed:', error);
      }
    }
    throw new Error('모든 프록시 실패');
  }
  
  static async searchGoogleNews(query) {
    const rssUrl = `https://news.google.com/rss/search?q=${encodeURIComponent(query)}&hl=ko&gl=KR&ceid=KR:ko`;
    
    try {
      const response = await ApiManager.fetchWithTimeout(
        `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(rssUrl)}`
      );
      const data = await response.json();
      
      if (data.status === 'ok') {
        return data.items.map(item => ({
          title: Utils.sanitizeText(item.title),
          link: item.link,
          pubDate: item.pubDate,
          source: 'google',
          score: 1
        }));
      }
    } catch (error) {
      console.warn('RSS2JSON failed:', error);
    }
    
    try {
      const xml = await this.fetchWithProxies(rssUrl);
      const parser = new DOMParser();
      const doc = parser.parseFromString(xml, 'application/xml');
      
      return Array.from(doc.querySelectorAll('item')).map(item => ({
        title: Utils.sanitizeText(item.querySelector('title')?.textContent || ''),
        link: item.querySelector('link')?.textContent || '',
        pubDate: item.querySelector('pubDate')?.textContent || '',
        source: 'google',
        score: 1
      }));
    } catch (error) {
      console.error('Google News search failed:', error);
      return [];
    }
  }
  
  static async searchNaverNews(query) {
    const naverUrls = [
      'https://rss.news.naver.com/services/news/mainnews.xml'
    ];
    
    const allItems = [];
    
    for (const url of naverUrls) {
      try {
        const xml = await this.fetchWithProxies(url);
        const parser = new DOMParser();
        const doc = parser.parseFromString(xml, 'application/xml');
        
        const items = Array.from(doc.querySelectorAll('item'))
          .map(item => ({
            title: Utils.sanitizeText(item.querySelector('title')?.textContent || ''),
            link: item.querySelector('link')?.textContent || '',
            pubDate: item.querySelector('pubDate')?.textContent || '',
            source: 'naver',
            score: 3
          }))
          .filter(item => {
            const titleLower = item.title.toLowerCase();
            const queryWords = query.toLowerCase().split(' ');
            return queryWords.some(word => titleLower.includes(word));
          });
        
        allItems.push(...items);
      } catch (error) {
        console.warn('Naver RSS failed:', error);
      }
    }
    
    return allItems;
  }
  
  static removeDuplicates(items) {
    const unique = [];
    
    for (const item of items) {
      const isDuplicate = unique.some(existing => 
        this.calculateSimilarity(item.title, existing.title) > 0.7
      );
      
      if (!isDuplicate) {
        unique.push(item);
      }
    }
    
    return unique;
  }
  
  static calculateSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const editDistance = this.getEditDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
  }
  
  static getEditDistance(s1, s2) {
    s1 = s1.toLowerCase();
    s2 = s2.toLowerCase();
    
    const costs = new Array(s2.length + 1);
    
    for (let i = 0; i <= s1.length; i++) {
      let lastValue = i;
      
      for (let j = 0; j <= s2.length; j++) {
        if (i === 0) {
          costs[j] = j;
        } else if (j > 0) {
          let newValue = costs[j - 1];
          if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
            newValue = Math.min(newValue, lastValue, costs[j]) + 1;
          }
          costs[j - 1] = lastValue;
          lastValue = newValue;
        }
      }
      
      if (i > 0) costs[s2.length] = lastValue;
    }
    
    return costs[s2.length];
  }
  
  static calculateFinalScore(item, query) {
    const timeScore = (Date.now() - new Date(item.pubDate)) / (1000 * 60 * 60);
    const keywords = query.toLowerCase().split(' ');
    const titleLower = item.title.toLowerCase();
    const keywordScore = keywords.reduce((score, keyword) => 
      score + (titleLower.includes(keyword) ? 1 : 0), 0
    );
    
    return item.score + keywordScore * 2 - timeScore * 0.1;
  }
}

// 콘텐츠 생성 클래스
class ContentGenerator {
  static async translateToEnglish(text) {
    try {
      const response = await ApiManager.fetchWithTimeout(
        `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=ko|en`
      );
      const data = await response.json();
      return data.responseData?.translatedText || text;
    } catch (error) {
      return text;
    }
  }
  
  static createSEOPrompt(articleTitle) {
    return `당신은 구글 SEO 전문가입니다. 키워드 스터핑 없이 자연스러운 8000자 이상의 블로그 글을 작성하세요.

기사 제목: ${articleTitle}

응답을 JSON 객체로만 반환하세요:
{
  "title": "SEO 최적화 제목 (60자 이내)",
  "meta_description": "메타 설명 (150자 이내)",
  "content": "8000자 이상 HTML 콘텐츠",
  "keywords": ["키워드1", "키워드2"],
  "tags": ["태그1", "태그2"]
}

요구사항:
- 키워드 밀도 1.5% 이하
- H2, H3 태그로 구조화
- 자연스러운 한국어
- 개인적 경험 포함
- FAQ 섹션 포함`;
  }
  
  static async generateContent(prompt) {
    try {
      const response = await ApiManager.callOpenAI(prompt, 0.6);
      let rawContent = response.choices[0].message.content.trim();
      rawContent = rawContent.replace(/^```(?:json)?/,'').replace(/```$/,'').trim();
      
      const data = JSON.parse(rawContent);
      
      // 기본값 설정
      data.keywords = Array.isArray(data.keywords) ? data.keywords : [data.keywords || ''];
      data.tags = Array.isArray(data.tags) ? data.tags : [data.tags || ''];
      data.meta_description = data.meta_description || 
        data.content.replace(/<[^>]*>/g, '').slice(0, 150) + '...';
      
      return data;
    } catch (error) {
      throw new Error('콘텐츠 생성 실패: ' + error.message);
    }
  }
}

// 내보내기 관리 클래스
class ExportManager {
  static async copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (error) {
      try {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        return true;
      } catch (fallbackError) {
        return false;
      }
    }
  }
  
  static downloadFile(content, filename, type) {
    try {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (error) {
      throw new Error('파일 다운로드 실패');
    }
  }
  
  static sanitizeFilename(filename) {
    return filename.replace(/[^a-zA-Z0-9가-힣]/g, '_').substring(0, 100);
  }
}

// 메인 애플리케이션 클래스
class App {
  constructor() {
    this.currentPost = null;
    this.searchResults = [];
    this.isGenerating = false;
    this.isSearching = false;
    
    this.initializeEventListeners();
    this.loadStoredKeys();
  }
  
  initializeEventListeners() {
    document.getElementById('saveKeysBtn').addEventListener('click', () => this.saveApiKeys());
    document.getElementById('searchBtn').addEventListener('click', () => this.searchArticles());
    document.getElementById('query').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.searchArticles();
    });
    document.getElementById('generateBtn').addEventListener('click', () => this.generateContent());
    document.getElementById('copyHtmlBtn').addEventListener('click', () => this.copyHtml());
    document.getElementById('copyMarkdownBtn').addEventListener('click', () => this.copyMarkdown());
    document.getElementById('downloadHtmlBtn').addEventListener('click', () => this.downloadHtml());
    document.getElementById('downloadMarkdownBtn').addEventListener('click', () => this.downloadMarkdown());
    document.getElementById('captureBtn').addEventListener('click', () => this.captureImage());
  }
  
  loadStoredKeys() {
    const keys = ['openai_key', 'pexels_key'];
    keys.forEach(key => {
      const element = document.getElementById(key);
      const stored = localStorage.getItem(key);
      if (element && stored) {
        element.value = stored;
      }
    });
  }
  
  saveApiKeys() {
    const openaiKey = document.getElementById('openai_key').value.trim();
    const pexelsKey = document.getElementById('pexels_key').value.trim();
    
    let hasError = false;
    
    if (openaiKey && !Utils.validateOpenAIKey(openaiKey)) {
      Utils.showMessage('openai_error', '올바른 OpenAI API 키 형식이 아닙니다.', true);
      hasError = true;
    }
    
    if (pexelsKey && !Utils.validatePexelsKey(pexelsKey)) {
      Utils.showMessage('pexels_error', 'Pexels API 키가 너무 짧습니다.', true);
      hasError = true;
    }
    
    if (hasError) return;
    
    if (openaiKey) localStorage.setItem('openai_key', openaiKey);
    if (pexelsKey) localStorage.setItem('pexels_key', pexelsKey);
    
    Utils.showMessage('keys_success', 'API 키가 저장되었습니다.');
  }
  
  async searchArticles() {
    if (this.isSearching) return;
    
    const query = document.getElementById('query').value.trim();
    if (!query) {
      alert('검색어를 입력해주세요.');
      return;
    }
    
    this.isSearching = true;
    document.getElementById('searchBtn').disabled = true;
    
    try {
      const googleResults = await NewsSearcher.searchGoogleNews(query);
      const naverResults = await NewsSearcher.searchNaverNews(query);
      
      const allResults = [...googleResults, ...naverResults];
      const uniqueResults = NewsSearcher.removeDuplicates(allResults);
      
      uniqueResults.forEach(item => {
        item.finalScore = NewsSearcher.calculateFinalScore(item, query);
      });
      
      this.searchResults = uniqueResults
        .sort((a, b) => b.finalScore - a.finalScore)
        .slice(0, CONFIG.MAX_ARTICLES);
      
      this.displaySearchResults();
      
    } catch (error) {
      console.error('Search failed:', error);
      alert('검색 중 오류가 발생했습니다: ' + error.message);
    } finally {
      this.isSearching = false;
      document.getElementById('searchBtn').disabled = false;
    }
  }
  
  displaySearchResults() {
    const container = document.getElementById('articles');
    const actionsSection = document.getElementById('actions');
    
    if (!this.searchResults.length) {
      container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">관련 기사를 찾을 수 없습니다.</p>';
      actionsSection.classList.add('hidden');
      return;
    }
    
    container.innerHTML = this.searchResults.map((item, index) => {
      const date = new Date(item.pubDate).toISOString().slice(0, 16).replace('T', ' ');
      const sourceIcon = item.source === 'naver' ? '🔥' : '📰';
      
      return `
        <div class="article-item">
          <input type="radio" name="article" id="article_${index}" value="${index}">
          <label for="article_${index}">
            ${sourceIcon} ${index + 1}. ${Utils.sanitizeText(item.title)} [${date}]
          </label>
        </div>
      `;
    }).join('');
    
    actionsSection.classList.remove('hidden');
  }
  
  async generateContent() {
    if (this.isGenerating) return;
    
    const selectedArticle = document.querySelector('input[name="article"]:checked');
    if (!selectedArticle) {
      alert('기사를 선택해주세요.');
      return;
    }
    
    const articleIndex = parseInt(selectedArticle.value);
    const article = this.searchResults[articleIndex];
    const query = document.getElementById('query').value.trim();
    
    this.isGenerating = true;
    this.currentPost = null;
    
    document.getElementById('generateBtn').disabled = true;
    
    const preview = document.getElementById('preview');
    preview.innerHTML = '<div style="text-align: center; padding: 2rem; color: #666;">콘텐츠 생성 중입니다...</div>';
    
    try {
      const prompt = ContentGenerator.createSEOPrompt(article.title);
      const data = await ContentGenerator.generateContent(prompt);
      
      if (!data.title || !data.content) {
        throw new Error('필수 데이터가 생성되지 않았습니다.');
      }
      
      // 대표 이미지 검색
      const featuredImage = await this.getFeaturedImage(article.title);
      
      const cleanContent = data.content.replace(/<img[^>]*>/gi, '');
      const imgHtml = featuredImage ? 
        `<img src="${featuredImage}" alt="대표 이미지" style="width: 100%; border-radius: 8px;">` : 
        '<p style="color: gray; text-align: center; padding: 1rem;">대표 이미지 없음</p>';
      
      preview.innerHTML = `
        <h3>${Utils.sanitizeText(data.title)}</h3>
        <p><strong>메타 설명:</strong> ${Utils.sanitizeText(data.meta_description)}</p>
        <p><strong>메인키워드:</strong> ${Utils.sanitizeText(query)}</p>
        <p><strong>키워드:</strong> ${data.keywords.map(k => Utils.sanitizeText(k)).join(', ')}</p>
        
        <div style="margin: 1rem 0; padding: 1rem; background: linear-gradient(135deg, #ff6b6b, #ee5a24); border-radius: 8px; color: white; text-align: center; font-weight: bold;">
          ${data.title} - SEO 최적화 완료
        </div>
        
        <div>${imgHtml}</div>
        <div style="margin-top: 1rem;">${cleanContent}</div>
      `;
      
      this.currentPost = {
        title: data.title,
        content: cleanContent,
        tags: data.tags,
        keywords: data.keywords,
        meta_description: data.meta_description,
        mainKeyword: query,
        imgUrl: featuredImage
      };
      
      document.getElementById('exportOptions').classList.remove('hidden');
      
    } catch (error) {
      console.error('Content generation failed:', error);
      preview.innerHTML = `<p style="color: red; text-align: center; padding: 2rem;">❌ ${error.message}</p>`;
    } finally {
      this.isGenerating = false;
      document.getElementById('generateBtn').disabled = false;
    }
  }
  
  async getFeaturedImage(title) {
    try {
      const englishTitle = await ContentGenerator.translateToEnglish(title);
      return await ApiManager.searchPexelsImage(englishTitle);
    } catch (error) {
      console.warn('Featured image search failed:', error);
      return null;
    }
  }
  
  async copyHtml() {
    if (!this.currentPost) {
      alert('먼저 콘텐츠를 생성해주세요.');
      return;
    }
    
    const htmlContent = this.buildHtmlContent();
    const success = await ExportManager.copyToClipboard(htmlContent);
    
    if (success) {
      alert('✅ HTML이 클립보드에 복사되었습니다!');
    } else {
      alert('❌ 클립보드 복사에 실패했습니다.');
    }
  }
  
  async copyMarkdown() {
    if (!this.currentPost) {
      alert('먼저 콘텐츠를 생성해주세요.');
      return;
    }
    
    const markdownContent = this.buildMarkdownContent();
    const success = await ExportManager.copyToClipboard(markdownContent);
    
    if (success) {
      alert('✅ Markdown이 클립보드에 복사되었습니다!');
    } else {
      alert('❌ 클립보드 복사에 실패했습니다.');
    }
  }
  
  downloadHtml() {
    if (!this.currentPost) {
      alert('먼저 콘텐츠를 생성해주세요.');
      return;
    }
    
    try {
      const htmlContent = this.buildCompleteHtmlDocument();
      const filename = ExportManager.sanitizeFilename(this.currentPost.title) + '.html';
      ExportManager.downloadFile(htmlContent, filename, 'text/html');
    } catch (error) {
      alert('❌ HTML 파일 다운로드에 실패했습니다.');
    }
  }
  
  downloadMarkdown() {
    if (!this.currentPost) {
      alert('먼저 콘텐츠를 생성해주세요.');
      return;
    }
    
    try {
      const markdownContent = this.buildMarkdownContent();
      const filename = ExportManager.sanitizeFilename(this.currentPost.title) + '.md';
      ExportManager.downloadFile(markdownContent, filename, 'text/markdown');
    } catch (error) {
      alert('❌ Markdown 파일 다운로드에 실패했습니다.');
    }
  }
  
  async captureImage() {
    if (!this.currentPost) {
      alert('먼저 콘텐츠를 생성해주세요.');
      return;
    }
    
    try {
      if (!window.html2canvas) {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        document.head.appendChild(script);
        await new Promise(resolve => script.onload = resolve);
      }
      
      const preview = document.getElementById('preview');
      const canvas = await html2canvas(preview, {
        backgroundColor: '#ffffff',
        scale: 2,
        useCORS: true
      });
      
      canvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = ExportManager.sanitizeFilename(this.currentPost.title) + '.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
      
    } catch (err) {
      console.error('Image capture failed:', err);
      alert('❌ 이미지 저장에 실패했습니다.');
    }
  }
  
  buildHtmlContent() {
    const post = this.currentPost;
    
    return `<h1>${Utils.sanitizeText(post.title)}</h1>
<p><strong>메타 설명:</strong> ${Utils.sanitizeText(post.meta_description)}</p>
<p><strong>메인키워드:</strong> ${Utils.sanitizeText(post.mainKeyword)}</p>
<p><strong>키워드:</strong> ${post.keywords.map(k => Utils.sanitizeText(k)).join(', ')}</p>
${post.imgUrl ? `<img src="${post.imgUrl}" alt="${Utils.sanitizeText(post.title)}" style="width: 100%; height: auto;">` : ''}
${post.content}`;
  }
  
  buildMarkdownContent() {
    const post = this.currentPost;
    
    return `# ${post.title}

**메타 설명:** ${post.meta_description}

**메인키워드:** ${post.mainKeyword}

**키워드:** ${post.keywords.join(', ')}

${post.imgUrl ? `![${post.title}](${post.imgUrl})\n\n` : ''}${this.htmlToMarkdown(post.content)}`;
  }
  
  htmlToMarkdown(html) {
    return html
      .replace(/<h([1-6])>(.*?)<\/h[1-6]>/gi, (match, level, text) => '#'.repeat(parseInt(level)) + ' ' + text + '\n\n')
      .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
      .replace(/<br\s*\/?>/gi, '\n')
      .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
      .replace(/<b>(.*?)<\/b>/gi, '**$1**')
      .replace(/<em>(.*?)<\/em>/gi, '*$1*')
      .replace(/<i>(.*?)<\/i>/gi, '*$1*')
      .replace(/<[^>]*>/g, '')
      .replace(/\n\s*\n\s*\n/g, '\n\n')
      .trim();
  }
  
  buildCompleteHtmlDocument() {
    const post = this.currentPost;
    
    return `<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="${Utils.sanitizeText(post.meta_description)}">
  <meta name="keywords" content="${post.keywords.map(k => Utils.sanitizeText(k)).join(', ')}">
  <title>${Utils.sanitizeText(post.title)}</title>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      max-width: 800px; 
      margin: 0 auto; 
      padding: 2rem; 
      line-height: 1.6; 
      color: #333;
    }
    h1 { 
      color: #2d3748; 
      border-bottom: 3px solid #e53e3e; 
      padding-bottom: 0.5rem; 
      margin-bottom: 2rem;
    }
    h2, h3 {
      color: #4a5568;
      margin-top: 2rem;
      margin-bottom: 1rem;
    }
    img { 
      width: 100%; 
      height: auto; 
      border-radius: 8px; 
      margin: 1rem 0; 
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .meta-info { 
      background: #f7fafc; 
      padding: 1rem; 
      border-radius: 8px; 
      margin: 1rem 0; 
      border-left: 4px solid #e53e3e;
    }
  </style>
</head>
<body>
  <h1>${Utils.sanitizeText(post.title)}</h1>
  <div class="meta-info">
    <p><strong>메타 설명:</strong> ${Utils.sanitizeText(post.meta_description)}</p>
    <p><strong>메인키워드:</strong> ${Utils.sanitizeText(post.mainKeyword)}</p>
    <p><strong>키워드:</strong> ${post.keywords.map(k => Utils.sanitizeText(k)).join(', ')}</p>
  </div>
  ${post.imgUrl ? `<img src="${post.imgUrl}" alt="${Utils.sanitizeText(post.title)}">` : ''}
  ${post.content}
</body>
</html>`;
  }
}

// DOM이 로드되면 앱 초기화
document.addEventListener('DOMContentLoaded', function() {
  try {
    new App();
  } catch (error) {
    console.error('App initialization failed:', error);
    alert('애플리케이션 초기화에 실패했습니다. 페이지를 새로고침해주세요.');
  }
});
</script>
</body>
</html>
